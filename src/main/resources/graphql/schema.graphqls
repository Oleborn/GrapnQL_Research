# ========================
#     SCALARS (СКАЛЯРЫ)
# ========================

# Определяем собственный скалярный тип — дата и время
# Скаляр (scalar) — это базовый атомарный тип данных, то есть то, что graphQl не может распарсить сам и отдает серверу.

# scalar — это базовые типы данных, которые не разворачиваются в другие поля.
# GraphQL поддерживает стандартные: Int, Float, String, Boolean, ID, но можно создавать кастомные.

scalar DateTime

# Ещё один кастомный тип для UUID
scalar UUID


# ========================
#         ENUMS
# ========================

# Перечисление возможных ролей пользователя
enum Role {
    ADMIN     # Администратор системы
    USER      # Обычный пользователь
    GUEST     # Гость без регистрации
}


# ========================
#      INTERFACES
# ========================

# interface описывает общие поля, которые должны быть у нескольких типов.
# Типы, которые реализуют интерфейс, обязаны содержать все его поля.
# Позволяет описывать полиморфизм.
# Клиент может запрашивать поля интерфейса, не зная конкретного типа.

# Интерфейс Node — общий для всех сущностей с id и временем создания
interface Node {
    #ID — это специальный встроенный скалярный тип GraphQL.
    #Он предназначен для уникальных идентификаторов объектов.
    # ! - знак обозначающий обязательность поля
    id: ID!              # Уникальный идентификатор
    createdAt: DateTime! # Дата и время создания
}


# ========================
#         TYPES
# ========================

# type описывает объект в GraphQL, который может возвращаться клиенту.
# Это самый базовый строительный блок схемы.

# Пользователь — реализует интерфейс Node
type User implements Node {
    id: ID!                  # Уникальный ID
    createdAt: DateTime!     # Когда создан
    name: String!            # Имя пользователя
    email: String!           # Электронная почта
    # [] - массив
    roles: [Role]!              # Роль (enum)
}


# ========================
#         UNION
# ========================

# union — это тип, который может быть любым из нескольких типов.
# Для поиска, где результат может быть разных типов.
# Используется с ... on TypeName для уточнения конкретного типа.

# Объединение типов — для универсального поиска
# Запрос может вернуть пользователя, пост или комментарий
union SearchResult = User


# ========================
#       INPUT TYPES
# ========================

# input — это входной тип, который используется в мутациях или аргументах запросов, когда нужно передать объект целиком.
# Нельзя использовать type как входной параметр, потому что GraphQL различает выходные типы и входные типы.

# Входной тип для создания пользователя
input CreateUserInput {
    name: String!             # Имя
    email: String!            # Почта
    role: Role = USER         # Роль (по умолчанию USER)
}

# Универсальный фильтр с параметрами поиска и пагинации
input FilterInput {
    limit: Int = 10           # Сколько элементов вернуть на странице (по умолчанию 10)
    offset: Int = 0           # страница (для пагинации)
    sortField: String            # Поле фильтрации (необязательный)
}


# ========================
#         QUERIES
# ========================

# Query — корневой тип для получения данных (чтение).
# Клиент запрашивает поля, выбирая вложенность.
# В Java реализуется через @QueryMapping в контроллере.

type Query {

    # Получить всех пользователей с фильтрацией
    # users - имя метода
    # (filter: FilterInput) входящие параметры метода
    # [User!]! возвращаемое значение
    users(filter: FilterInput): [User!]!

    # Получить конкретного пользователя по ID
    user(id: ID!): User
}


# ========================
#        MUTATIONS
# ========================

# Mutation — корневой тип для изменения данных (создание, обновление, удаление).
type Mutation {

    # Создать нового пользователя
    createUser(input: CreateUserInput!): User!
    }


# ========================
#      SUBSCRIPTIONS
# ========================

# Subscription — корневой тип для подписок на события в реальном времени.
# Через WebSocket или SSE
# Клиент получает уведомления при создании/обновлении объектов
type Subscription {

    # Когда появляется новый user — уведомить подписчиков
    newUser: User!

}
